/**
 * AGENTS.md Generator
 *
 * Transforms scan results into formatted documentation. Supports multiple
 * output modes:
 * - Default: Full documentation with all sections
 * - Compact: Reduced detail (~20% smaller)
 * - Compress: Signatures only (~40% smaller)
 * - Minimal: Ultra-compact (~3K tokens)
 * - XML: Structured XML format (Repomix compatible)
 *
 * @module generator
 */

import type { ScanResult, Component, Framework, Tokens, Hook, Utilities, Commands, ExistingContext, ComponentVariant, ApiRoute, ApiSchema, EnvVar, DetectedPatterns, DatabaseSchema, FileStats, BarrelExport, ComponentDependency, FileTree, ImportGraph, TypeScanResult, AntiPatternsResult } from "./types.js";
import { extractRulesFromClaudeMd } from "./scanners/existing-context.js";
import { formatFileTree } from "./scanners/file-tree.js";
import { formatImportGraph } from "./scanners/imports.js";
import { formatTypes } from "./scanners/types.js";
import { formatAntiPatterns } from "./scanners/anti-patterns.js";

/** Options for controlling AGENTS.md generation */
export interface GeneratorOptions {
  compact?: boolean;
  compress?: boolean;
  minimal?: boolean;      // Ultra-compact: TL;DR + rules + component names only (~1K tokens)
  includeTree?: boolean;  // Include file tree (off by default)
  xml?: boolean;          // XML format (industry standard, matches Repomix)
}

/**
 * Generates AGENTS.md content from scan results
 *
 * @param result - Complete scan results from all scanners
 * @param options - Output options (compact, compress, minimal, xml)
 * @returns Formatted markdown or XML string
 *
 * @example
 * const content = generateAgentsMd(scanResult, { compact: true });
 * writeFileSync('AGENTS.md', content);
 */
export function generateAgentsMd(result: ScanResult, options: GeneratorOptions = {}): string {
  const { components, tokens, framework, hooks, utilities, commands, existingContext, variants, apiRoutes, envVars, patterns, database, stats, barrels, dependencies, fileTree, importGraph, typeExports, antiPatterns } = result;
  const { compact = false, compress = false, minimal = false, includeTree = false, xml = false } = options;

  // Minimal mode: ultra-compact output (~1K tokens)
  if (minimal) {
    return generateMinimalOutput(result, options);
  }

  // XML mode: structured output (industry standard, matches Repomix)
  if (xml) {
    return generateXmlOutput(result);
  }

  const lines: string[] = [];

  // Header
  lines.push("# AGENTS.md");
  lines.push("");
  lines.push("> Auto-generated by [agentsmith](https://github.com/jpoindexter/agentsmith)");
  lines.push("");

  // TL;DR - Quick Reference
  lines.push("## TL;DR");
  lines.push("");

  // Stack line with versions
  const stackParts: string[] = [];
  if (framework.name !== "Unknown") {
    stackParts.push(framework.version ? `${framework.name} ${framework.version}` : framework.name);
  }
  if (framework.language === "TypeScript") {
    stackParts.push(framework.versions?.typescript ? `TypeScript ${framework.versions.typescript}` : "TypeScript");
  }
  if (framework.styling) {
    stackParts.push(framework.versions?.tailwindcss ? `Tailwind ${framework.versions.tailwindcss}` : framework.styling);
  }
  if (utilities.hasShadcn) stackParts.push("shadcn/ui");
  lines.push(`- **Stack**: ${stackParts.join(" + ")}`);

  // Components
  lines.push(`- **Components**: ${components.length} total â€” USE EXISTING, don't create new`);

  // Key imports
  const keyImports: string[] = [];
  if (utilities.hasCn) keyImports.push(`\`cn()\` from \`${utilities.cnPath}\``);
  if (utilities.hasMode) keyImports.push(`\`mode\` from \`${utilities.modePath}\``);
  if (keyImports.length > 0) {
    lines.push(`- **Key imports**: ${keyImports.join(", ")}`);
  }

  // Hub files (most impactful)
  if (importGraph && importGraph.hubFiles.length > 0) {
    const topHubs = importGraph.hubFiles.slice(0, 4).map(h => {
      const parts = h.file.split("/");
      const filename = parts.pop()?.replace(/\.(ts|tsx|js|jsx)$/, "") || "";
      // For index files, show parent/index (e.g., "design-system/index")
      if (filename === "index" && parts.length > 0) {
        return `${parts.pop()}/${filename}`;
      }
      return filename;
    });
    lines.push(`- **High-impact files**: ${topHubs.join(", ")} (changes affect many files)`);
  }

  // Database
  if (database && database.models.length > 0) {
    lines.push(`- **Database**: ${database.provider} with ${database.models.length} models`);
  }

  // API routes
  if (apiRoutes.length > 0) {
    const protectedCount = apiRoutes.filter(r => r.isProtected).length;
    lines.push(`- **API**: ${apiRoutes.length} routes (${protectedCount} protected)`);
  }

  // Critical rules summary
  lines.push("");
  lines.push("**Rules**: Use design tokens (not hardcoded colors), use `cn()` for classes, check existing components first");
  lines.push("");

  // Getting Started Section (auto-generated setup guide)
  const gettingStarted = generateGettingStarted(result);
  if (gettingStarted) {
    lines.push(gettingStarted);
  }

  // Project Overview
  lines.push("## Project Overview");
  lines.push("");
  lines.push("| | |");
  lines.push("|---|---|");
  lines.push(`| **Framework** | ${framework.name}${framework.version ? ` ${framework.version}` : ""}${framework.router ? ` (${framework.router})` : ""} |`);
  lines.push(`| **Language** | ${framework.language} |`);
  if (framework.styling) {
    lines.push(`| **Styling** | ${framework.styling} |`);
  }
  if (utilities.hasShadcn) {
    lines.push(`| **UI Library** | shadcn/ui (${utilities.radixPackages.length} Radix packages) |`);
  }
  if (utilities.hasCn) {
    lines.push(`| **Class Utility** | \`cn()\` from \`${utilities.cnPath}\` |`);
  }
  if (utilities.hasMode) {
    lines.push(`| **Design System** | \`mode\` from \`${utilities.modePath}\` |`);
  }
  lines.push(`| **Components** | ${components.length} |`);
  if (hooks.length > 0) {
    lines.push(`| **Custom Hooks** | ${hooks.length} |`);
  }
  if (apiRoutes.length > 0) {
    lines.push(`| **API Routes** | ${apiRoutes.length} |`);
  }
  if (patterns.patterns.length > 0) {
    lines.push(`| **Patterns** | ${patterns.patterns.length} detected |`);
  }
  if (stats) {
    lines.push(`| **Codebase** | ${stats.totalFiles} files, ${stats.totalLines.toLocaleString()} lines |`);
  }
  lines.push("");

  // File Tree Section (only when --tree flag is used)
  if (includeTree && fileTree) {
    lines.push(formatFileTree(fileTree));
  }

  // Critical Rules with inline examples (moved anti-patterns here for better AI parsing)
  lines.push("## Critical Rules");
  lines.push("");
  lines.push("**These rules are NON-NEGOTIABLE:**");
  lines.push("");

  // Rule 1: Use existing components
  lines.push("### 1. USE EXISTING COMPONENTS");
  lines.push(`This project has ${components.length} components. Check the list below before creating anything new.`);
  lines.push("");
  lines.push("```tsx");
  lines.push("// WRONG");
  lines.push(`<div className="rounded border p-4">...</div>`);
  lines.push("");
  lines.push("// RIGHT");
  lines.push(`<Card><CardContent>...</CardContent></Card>`);
  lines.push("```");
  lines.push("");

  // Rule 2: Use design tokens
  lines.push("### 2. USE DESIGN TOKENS");
  lines.push("Never hardcode colors. Use semantic tokens that work with theme switching.");
  lines.push("");
  lines.push("```tsx");
  lines.push("// WRONG");
  lines.push(`className="bg-blue-500 text-white"`);
  lines.push(`style={{ color: "#3b82f6" }}`);
  lines.push("");
  lines.push("// RIGHT");
  lines.push(`className="bg-primary text-primary-foreground"`);
  lines.push("```");
  lines.push("");

  // Rule 3: cn() utility
  if (utilities.hasCn) {
    lines.push("### 3. USE `cn()` FOR CLASSES");
    lines.push(`Import from \`${utilities.cnPath}\`. Handles conditional classes correctly.`);
    lines.push("");
    lines.push("```tsx");
    lines.push("// WRONG");
    lines.push(`className={"btn " + (active ? "btn-active" : "")}`);
    lines.push("");
    lines.push("// RIGHT");
    lines.push(`className={cn("btn", active && "btn-active")}`);
    lines.push("```");
    lines.push("");
  }

  // Rule 4: mode design system
  if (utilities.hasMode) {
    lines.push(`### ${utilities.hasCn ? "4" : "3"}. USE \`mode\` DESIGN SYSTEM`);
    lines.push(`Import from \`${utilities.modePath}\`. Provides theme-aware styling.`);
    lines.push("");
    lines.push("```tsx");
    lines.push("// WRONG");
    lines.push(`className="rounded-lg"`);
    lines.push("");
    lines.push("// RIGHT");
    lines.push(`className={cn("...", mode.radius)}`);
    lines.push("```");
    lines.push("");
  }

  // Extract rules from existing CLAUDE.md if present
  if (existingContext.hasClaudeMd && existingContext.claudeMdContent) {
    const extractedRules = extractRulesFromClaudeMd(existingContext.claudeMdContent);
    if (extractedRules.length > 0) {
      lines.push("### Additional Rules (from CLAUDE.md)");
      lines.push("");
      for (const rule of extractedRules.slice(0, 10)) {
        lines.push(`- ${rule}`);
      }
      lines.push("");
    }
  }

  // Framework-specific rules
  const frameworkRules = getFrameworkRules(framework, tokens, utilities);
  if (frameworkRules.length > 0) {
    lines.push("### Framework-Specific");
    lines.push("");
    for (const rule of frameworkRules) {
      lines.push(`- ${rule}`);
    }
    lines.push("");
  }

  // Components Section
  if (components.length > 0) {
    lines.push("## Components");
    lines.push("");

    const grouped = groupComponentsByDirectory(components);
    const groupCount = Object.keys(grouped).length;

    lines.push(`${components.length} components across ${groupCount} categories.`);
    lines.push("");

    // Sort groups: UI first, then Charts, then alphabetically
    const sortedGroups = Object.entries(grouped).sort((a, b) => {
      const aName = formatDirectoryName(a[0]);
      const bName = formatDirectoryName(b[0]);
      if (aName === "UI Components") return -1;
      if (bName === "UI Components") return 1;
      if (aName === "Charts") return -1;
      if (bName === "Charts") return 1;
      return aName.localeCompare(bName);
    });

    for (const [dir, comps] of sortedGroups) {
      const groupName = formatDirectoryName(dir);
      lines.push(`### ${groupName} (${comps.length})`);
      lines.push("");

      for (const comp of comps) {
        const allExports = comp.exports.map(e => `\`${e}\``).join(", ");
        lines.push(`- ${allExports} â€” \`${comp.importPath}\``);

        // Compress mode: minimal output, just component names and paths
        if (compress) {
          // Skip all details in compress mode
          continue;
        }

        // In compact mode, limit props to 5 and skip descriptions
        if (!compact) {
          // Add props if available
          if (comp.props && comp.props.length > 0) {
            lines.push(`  - Props: ${comp.props.join(", ")}`);
          }

          // Add description if available
          if (comp.description) {
            lines.push(`  - ${comp.description}`);
          }
        } else if (comp.props && comp.props.length > 0) {
          // Compact: show top 5 props only
          const topProps = comp.props.slice(0, 5);
          const more = comp.props.length > 5 ? ` (+${comp.props.length - 5})` : "";
          lines.push(`  - Props: ${topProps.join(", ")}${more}`);
        }
      }
      lines.push("");
    }
  }

  // Barrel Imports Section
  if (barrels && barrels.length > 0) {
    lines.push("## Preferred Imports");
    lines.push("");
    lines.push("Use barrel imports instead of importing from individual files:");
    lines.push("");
    lines.push("```typescript");
    for (const barrel of barrels.slice(0, 5)) {
      const exampleExports = barrel.exports
        .filter(e => !e.startsWith("*"))
        .slice(0, 4)
        .join(", ");
      if (exampleExports) {
        lines.push(`import { ${exampleExports} } from "${barrel.importPath}";`);
      }
    }
    lines.push("```");
    lines.push("");
  }

  // Hooks Section
  if (hooks.length > 0) {
    lines.push("## Custom Hooks");
    lines.push("");
    for (const hook of hooks) {
      const clientNote = hook.isClientOnly ? " *(client only)*" : "";
      lines.push(`- \`${hook.name}\` â€” \`${hook.importPath}\`${clientNote}`);
    }
    lines.push("");
  }

  // TypeScript Types Section (skip in compact/compress mode)
  if (!compact && !compress && typeExports && (typeExports.propsTypes.length > 0 || typeExports.apiTypes.length > 0)) {
    lines.push(formatTypes(typeExports));
  }

  // Utilities Section
  if (utilities.customUtils.length > 0 || utilities.hasCn) {
    lines.push("## Utilities");
    lines.push("");
    if (utilities.hasCn) {
      lines.push(`- \`cn(...classes)\` â€” Class merging utility from \`${utilities.cnPath}\``);
    }
    for (const util of utilities.customUtils.slice(0, 10)) {
      lines.push(`- \`${util}()\` â€” from \`${utilities.cnPath}\``);
    }
    lines.push("");
  }

  // Component Dependencies Section (skip in compact mode)
  if (!compact && dependencies && dependencies.length > 0) {
    // Only show components with interesting dependencies
    const interestingDeps = dependencies.filter(
      d => d.imports.radix.length > 0 || d.imports.designSystem.length > 0
    ).slice(0, 15);

    if (interestingDeps.length > 0) {
      lines.push("## Component Dependencies");
      lines.push("");
      lines.push("Key imports for each component:");
      lines.push("");

      for (const dep of interestingDeps) {
        const parts: string[] = [];
        if (dep.imports.utilities.length > 0) {
          parts.push(dep.imports.utilities.join(", "));
        }
        if (dep.imports.designSystem.length > 0) {
          parts.push(dep.imports.designSystem.join(", "));
        }
        if (dep.imports.radix.length > 0) {
          parts.push(`@radix-ui/${dep.imports.radix.join(", @radix-ui/")}`);
        }

        if (parts.length > 0) {
          lines.push(`- **${dep.component}** â†’ ${parts.join(", ")}`);
        }
      }
      lines.push("");
    }
  }

  // Import Graph Section (hub files, circular deps, external deps)
  if (!compact && !compress && importGraph) {
    lines.push(formatImportGraph(importGraph));
  }

  // Component Variants Section
  if (variants.length > 0) {
    lines.push("## Component Variants");
    lines.push("");
    lines.push("Components with CVA variants (use these instead of custom styling):");
    lines.push("");

    for (const v of variants.slice(0, 15)) {
      const variantTypes = Object.entries(v.variants)
        .map(([type, options]) => `${type}: ${options.join(", ")}`)
        .join(" | ");

      lines.push(`- **${v.component}** â€” ${variantTypes}`);
      if (v.defaultVariants) {
        const defaults = Object.entries(v.defaultVariants)
          .map(([k, val]) => `${k}="${val}"`)
          .join(", ");
        lines.push(`  - Defaults: ${defaults}`);
      }
    }
    if (variants.length > 15) {
      lines.push(`- ... and ${variants.length - 15} more`);
    }
    lines.push("");
  }

  // API Routes Section (grouped by base path)
  if (apiRoutes.length > 0) {
    lines.push("## API Routes");
    lines.push("");

    // Count routes with schemas
    const routesWithSchemas = apiRoutes.filter(r =>
      r.requestSchema || r.responseSchema || r.querySchema
    ).length;

    if (routesWithSchemas > 0) {
      lines.push(`${apiRoutes.length} API endpoints (${routesWithSchemas} with schemas):`);
    } else {
      lines.push(`${apiRoutes.length} API endpoints:`);
    }
    lines.push("");

    // Group routes by base path
    const groupedRoutes = groupRoutesByBasePath(apiRoutes);
    const sortedGroups = Object.entries(groupedRoutes).sort((a, b) => a[0].localeCompare(b[0]));

    for (const [group, routes] of sortedGroups) {
      lines.push(`### ${group}`);
      lines.push("");
      for (const route of routes) {
        const methods = route.methods.join(", ");
        const auth = route.isProtected ? " ðŸ”’" : "";
        lines.push(`- \`${methods}\` \`${route.path}\`${auth}`);

        // Add schema information (skip in compress/minimal modes)
        if (!compress && !minimal) {
          if (route.requestSchema && route.requestSchema.fields.length > 0) {
            lines.push(`  - **Request**: ${formatSchema(route.requestSchema, compact)}`);
          }
          if (route.querySchema && route.querySchema.fields.length > 0) {
            lines.push(`  - **Query**: ${formatSchema(route.querySchema, compact)}`);
          }
          if (route.responseSchema && route.responseSchema.fields.length > 0) {
            lines.push(`  - **Response**: ${formatSchema(route.responseSchema, compact)}`);
          }
        }
      }
      lines.push("");
    }
  }

  // Database Models Section
  if (database && database.models.length > 0) {
    lines.push("## Database Models");
    lines.push("");
    lines.push(`${database.models.length} ${database.provider} models:`);
    lines.push("");

    for (const model of database.models.slice(0, 20)) {
      const fieldList = model.fields.slice(0, 6).join(", ");
      const moreFields = model.fields.length > 6 ? `, +${model.fields.length - 6} more` : "";
      lines.push(`- **${model.name}** â€” ${fieldList}${moreFields}`);

      if (model.relations.length > 0) {
        lines.push(`  - Relations: ${model.relations.join(", ")}`);
      }
    }
    if (database.models.length > 20) {
      lines.push(`- ... and ${database.models.length - 20} more`);
    }
    lines.push("");
  }

  // Environment Variables Section
  if (envVars.length > 0) {
    lines.push("## Environment Variables");
    lines.push("");

    // Group by category if available
    const required = envVars.filter(e => e.required);
    const optional = envVars.filter(e => !e.required);

    if (required.length > 0) {
      lines.push("### Required");
      lines.push("");
      lines.push("```bash");
      for (const env of required.slice(0, 20)) {
        lines.push(env.name);
      }
      lines.push("```");
      lines.push("");
    }

    if (optional.length > 0) {
      lines.push("### Optional");
      lines.push("");
      lines.push("```bash");
      for (const env of optional.slice(0, 15)) {
        lines.push(env.name);
      }
      if (optional.length > 15) {
        lines.push(`# ... and ${optional.length - 15} more`);
      }
      lines.push("```");
      lines.push("");
    }
  }

  // Detected Patterns Section
  if (patterns.patterns.length > 0) {
    lines.push("## Code Patterns");
    lines.push("");
    lines.push("Detected patterns in this codebase:");
    lines.push("");

    for (const pattern of patterns.patterns) {
      lines.push(`- ${pattern}`);
    }
    lines.push("");

    // Form pattern guidance
    if (patterns.hasReactHookForm && patterns.hasZod) {
      lines.push("### Form Pattern");
      lines.push("");
      lines.push("```typescript");
      lines.push('import { useForm } from "react-hook-form";');
      lines.push('import { zodResolver } from "@hookform/resolvers/zod";');
      lines.push('import { z } from "zod";');
      lines.push("");
      lines.push("const schema = z.object({");
      lines.push('  name: z.string().min(1, "Required"),');
      lines.push('  email: z.string().email(),');
      lines.push("});");
      lines.push("");
      lines.push("const form = useForm({");
      lines.push("  resolver: zodResolver(schema),");
      lines.push("});");
      lines.push("```");
      lines.push("");
    }
  }

  // Design Tokens
  if (Object.keys(tokens.colors).length > 0) {
    lines.push("## Design Tokens");
    lines.push("");

    // Mode object documentation if present
    if (utilities.hasMode) {
      lines.push("### Using the `mode` Object");
      lines.push("");
      lines.push("```typescript");
      lines.push(`import { mode } from "${utilities.modePath}";`);
      lines.push(`import { cn } from "${utilities.cnPath || "@/lib/utils"}";`);
      lines.push("");
      lines.push("// Usage in components:");
      lines.push("className={cn(");
      lines.push('  "base-styles",');
      lines.push("  mode.radius,        // Dynamic border radius");
      lines.push("  mode.color.bg.surface,");
      lines.push("  mode.typography.body.m");
      lines.push(")}");
      lines.push("```");
      lines.push("");
    }

    lines.push("### Color Tokens");
    lines.push("");
    lines.push("**Use semantic classes, never hardcoded colors:**");
    lines.push("");
    lines.push("```");
    lines.push("// Backgrounds");
    lines.push("bg-background, bg-card, bg-muted, bg-primary, bg-secondary, bg-destructive, bg-accent");
    lines.push("");
    lines.push("// Text");
    lines.push("text-foreground, text-muted-foreground, text-primary-foreground, text-destructive");
    lines.push("");
    lines.push("// Borders");
    lines.push("border-border, border-primary, border-destructive");
    lines.push("");
    lines.push("// NEVER USE:");
    lines.push("// bg-white, bg-black, bg-gray-500, text-gray-600, #ffffff, rgb(...)");
    lines.push("```");
    lines.push("");

    // Show actual token values (collapsed for reference)
    if (Object.keys(tokens.colors).length > 0) {
      lines.push("<details>");
      lines.push("<summary>Raw CSS Variables (click to expand)</summary>");
      lines.push("");
      lines.push("```css");
      for (const [name, value] of Object.entries(tokens.colors).slice(0, 30)) {
        lines.push(`--${name}: ${value};`);
      }
      if (Object.keys(tokens.colors).length > 30) {
        lines.push(`/* ... and ${Object.keys(tokens.colors).length - 30} more */`);
      }
      lines.push("```");
      lines.push("");
      lines.push("</details>");
      lines.push("");
    }
  }

  // Anti-Patterns Section (additional patterns not covered in Critical Rules)
  // Only show in full mode, and only framework-specific patterns
  if (!compress && !compact && antiPatterns && antiPatterns.patterns.length > 0) {
    const additionalPatterns = antiPatterns.patterns.filter(p =>
      p.title.includes("Next.js") ||
      p.title.includes("TypeScript") ||
      p.title.includes("API") ||
      p.title.includes("'use client'")
    );
    if (additionalPatterns.length > 0) {
      lines.push("## Additional Guidelines");
      lines.push("");
      for (const pattern of additionalPatterns.slice(0, 5)) {
        lines.push(`**${pattern.title}**`);
        lines.push(`- Wrong: \`${pattern.wrong.split('\n')[0]}\``);
        lines.push(`- Right: \`${pattern.right.split('\n')[0]}\``);
        lines.push("");
      }
    }
  }

  // Commands Section
  if (commands.dev || commands.build || Object.keys(commands.custom).length > 0) {
    lines.push("## Commands");
    lines.push("");
    lines.push("```bash");
    if (commands.dev) lines.push(`npm run dev          # ${commands.dev}`);
    if (commands.build) lines.push(`npm run build        # ${commands.build}`);
    if (commands.test) lines.push(`npm test             # ${commands.test}`);
    if (commands.lint) lines.push(`npm run lint         # ${commands.lint}`);
    if (commands.typecheck) lines.push(`npm run typecheck    # ${commands.typecheck}`);
    lines.push("```");
    lines.push("");

    // Database commands
    if (commands.db && Object.keys(commands.db).length > 0) {
      lines.push("### Database");
      lines.push("");
      lines.push("```bash");
      for (const [name, cmd] of Object.entries(commands.db)) {
        lines.push(`npm run ${name}`);
      }
      lines.push("```");
      lines.push("");
    }

    // Custom/AI commands
    if (Object.keys(commands.custom).length > 0) {
      lines.push("### Other Commands");
      lines.push("");
      lines.push("```bash");
      for (const [name] of Object.entries(commands.custom).slice(0, 10)) {
        lines.push(`npm run ${name}`);
      }
      lines.push("```");
      lines.push("");
    }
  }

  // Reference to existing docs
  if (existingContext.hasClaudeMd || existingContext.hasAiFolder) {
    lines.push("## Additional Documentation");
    lines.push("");
    if (existingContext.hasClaudeMd) {
      lines.push(`- **${existingContext.claudeMdPath}** â€” Detailed project documentation`);
    }
    if (existingContext.hasAiFolder) {
      lines.push(`- **.ai/ folder** â€” AI-native context files:`);
      for (const file of existingContext.aiFiles.slice(0, 10)) {
        lines.push(`  - \`${file}\``);
      }
      if (existingContext.aiFiles.length > 10) {
        lines.push(`  - ... and ${existingContext.aiFiles.length - 10} more`);
      }
    }
    lines.push("");
  }

  return lines.join("\n");
}

function getFrameworkRules(framework: Framework, tokens: Tokens, utilities: Utilities): string[] {
  const rules: string[] = [];

  // Next.js rules
  if (framework.name === "Next.js") {
    if (framework.router === "App Router") {
      rules.push("Use `'use client'` directive only when component needs interactivity");
      rules.push("Prefer Server Components by default");
      rules.push("Use `next/image` for images, `next/link` for navigation");
    }
  }

  // Tailwind rules
  if (framework.styling === "Tailwind CSS") {
    rules.push("Never use arbitrary values (`w-[137px]`) â€” use scale values");
    if (Object.keys(tokens.radius).length > 0) {
      rules.push("Use design system radius tokens, not arbitrary rounded values");
    }
  }

  // shadcn/ui rules
  if (utilities.hasShadcn) {
    rules.push("Use `asChild` prop when wrapping components with custom elements");
    rules.push("Use CVA variants for consistent component styling");
  }

  // TypeScript rules
  if (framework.language === "TypeScript") {
    rules.push("Type all props and function parameters");
    rules.push("Avoid `any` â€” use proper types or `unknown`");
  }

  return rules;
}

function groupComponentsByDirectory(components: Component[]): Record<string, Component[]> {
  const grouped: Record<string, Component[]> = {};

  for (const comp of components) {
    const parts = comp.path.split("/");
    parts.pop();
    const dir = parts.join("/") || "root";

    if (!grouped[dir]) {
      grouped[dir] = [];
    }
    grouped[dir].push(comp);
  }

  return grouped;
}

function formatDirectoryName(dir: string): string {
  const lastPart = dir.split("/").pop() || dir;

  if (lastPart === "ui") return "UI Components";
  if (lastPart === "charts") return "Charts";
  if (lastPart === "auth") return "Auth Components";
  if (lastPart === "admin") return "Admin Components";
  if (lastPart === "billing") return "Billing Components";

  return lastPart
    .split(/[-_]/)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(" ");
}

function groupRoutesByBasePath(routes: ApiRoute[]): Record<string, ApiRoute[]> {
  const grouped: Record<string, ApiRoute[]> = {};

  for (const route of routes) {
    // Extract base path: /api/users/[id] -> Users
    const parts = route.path.split("/").filter(Boolean);
    // Skip "api" prefix if present
    const startIndex = parts[0] === "api" ? 1 : 0;
    const basePath = parts[startIndex] || "root";

    // Format group name: users -> Users, user-settings -> User Settings
    const groupName = basePath
      .replace(/\[.*?\]/g, "") // Remove dynamic segments
      .replace(/-/g, " ")
      .split(" ")
      .filter(Boolean)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(" ") || "Other";

    if (!grouped[groupName]) {
      grouped[groupName] = [];
    }
    grouped[groupName].push(route);
  }

  return grouped;
}

/**
 * Formats an API schema for display
 * Compact mode shows fewer fields, normal shows up to 5
 */
function formatSchema(schema: ApiSchema, compact: boolean = false): string {
  const maxFields = compact ? 3 : 5;
  const typeName = schema.name ? `${schema.name} ` : '';

  const fields = schema.fields.slice(0, maxFields).map(f => {
    const optional = f.isOptional ? '?' : '';
    const validations = f.validations && f.validations.length > 0
      ? ` (${f.validations.join(', ')})`
      : '';

    // Show nested indicator
    const nested = f.nested && f.nested.length > 0 ? ' {...}' : '';

    return `${f.name}${optional}: ${f.type}${validations}${nested}`;
  });

  const remaining = schema.fields.length - maxFields;
  const more = remaining > 0 ? `, +${remaining} more` : '';

  return `${typeName}{ ${fields.join(', ')}${more} }`;
}

/**
 * Generate minimal output (~3K tokens)
 * TL;DR + Rules with inline examples + Component names only
 */
function generateMinimalOutput(result: ScanResult, options: GeneratorOptions): string {
  const { components, framework, utilities, hooks, apiRoutes, database, importGraph } = result;
  const lines: string[] = [];

  // Header
  lines.push("# AGENTS.md");
  lines.push("");
  lines.push("> Minimal output â€¢ [agentsmith](https://github.com/jpoindexter/agentsmith)");
  lines.push("");

  // Quick Reference
  lines.push("## Quick Reference");
  lines.push("");
  const stackParts: string[] = [framework.name];
  if (framework.language === "TypeScript") stackParts.push("TypeScript");
  if (framework.styling) stackParts.push(framework.styling);
  lines.push(`**Stack**: ${stackParts.join(" + ")}`);
  lines.push(`**Components**: ${components.length} â€” USE EXISTING`);
  if (utilities.hasCn) lines.push(`**Utility**: \`cn()\` from \`${utilities.cnPath}\``);
  if (utilities.hasMode) lines.push(`**Design**: \`mode\` from \`${utilities.modePath}\``);
  if (database) lines.push(`**Database**: ${database.provider} (${database.models.length} models)`);
  lines.push("");

  // Rules (compact with inline examples)
  lines.push("## Rules");
  lines.push("");
  lines.push("1. **USE EXISTING COMPONENTS** â€” Don't create new ones");
  lines.push("   - WRONG: `<div className=\"rounded border\">` â†’ RIGHT: `<Card>`");
  lines.push("");
  lines.push("2. **USE DESIGN TOKENS** â€” No hardcoded colors");
  lines.push("   - WRONG: `bg-blue-500` â†’ RIGHT: `bg-primary`");
  lines.push("");
  if (utilities.hasCn) {
    lines.push("3. **USE `cn()`** â€” For conditional classes");
    lines.push("   - WRONG: `\"btn \" + (x ? \"active\" : \"\")` â†’ RIGHT: `cn(\"btn\", x && \"active\")`");
    lines.push("");
  }
  if (framework.name === "Next.js") {
    lines.push(`${utilities.hasCn ? "4" : "3"}. **NEXT.JS** â€” Use Link/Image, prefer Server Components`);
    lines.push("");
  }

  // Components (names only, grouped)
  lines.push("## Components");
  lines.push("");
  const grouped = groupComponentsByDirectory(components);
  for (const [dir, comps] of Object.entries(grouped)) {
    const groupName = formatDirectoryName(dir);
    const names = comps.map(c => c.name).join(", ");
    lines.push(`**${groupName}**: ${names}`);
  }
  lines.push("");

  // Hooks (if any)
  if (hooks.length > 0) {
    lines.push("## Hooks");
    lines.push("");
    lines.push(hooks.map(h => `\`${h.name}\``).join(", "));
    lines.push("");
  }

  // Hub files (most impactful)
  if (importGraph && importGraph.hubFiles.length > 0) {
    lines.push("## High-Impact Files");
    lines.push("");
    for (const hub of importGraph.hubFiles.slice(0, 5)) {
      lines.push(`- \`${hub.file}\` (${hub.importedByCount} dependents)`);
    }
    lines.push("");
  }

  return lines.join("\n");
}

/**
 * Generate XML-structured output (industry standard, matches Repomix)
 */
function generateXmlOutput(result: ScanResult): string {
  const { components, tokens, framework, utilities, hooks, apiRoutes, database, importGraph } = result;
  const lines: string[] = [];

  lines.push('<?xml version="1.0" encoding="UTF-8"?>');
  lines.push('<agents-context version="1.0">');
  lines.push('');

  // Summary
  lines.push('  <summary>');
  const stackParts: string[] = [framework.name];
  if (framework.language === "TypeScript") stackParts.push("TypeScript");
  if (framework.styling) stackParts.push(framework.styling);
  lines.push(`    <stack>${stackParts.join(" + ")}</stack>`);
  lines.push(`    <components count="${components.length}">USE EXISTING - don't create new</components>`);
  if (utilities.hasCn) lines.push(`    <utility name="cn" path="${escapeXml(utilities.cnPath || '')}" />`);
  if (utilities.hasMode) lines.push(`    <utility name="mode" path="${escapeXml(utilities.modePath || '')}" />`);
  if (database) lines.push(`    <database provider="${database.provider}" models="${database.models.length}" />`);
  lines.push('  </summary>');
  lines.push('');

  // Rules with examples
  lines.push('  <rules priority="critical">');
  lines.push('    <rule name="use-existing-components">');
  lines.push(`      <description>This project has ${components.length} components. Check before creating new.</description>`);
  lines.push('      <example type="wrong"><![CDATA[<div className="rounded border p-4">...</div>]]></example>');
  lines.push('      <example type="right"><![CDATA[<Card><CardContent>...</CardContent></Card>]]></example>');
  lines.push('    </rule>');
  lines.push('    <rule name="use-design-tokens">');
  lines.push('      <description>Never hardcode colors. Use semantic tokens.</description>');
  lines.push('      <example type="wrong"><![CDATA[className="bg-blue-500 text-white"]]></example>');
  lines.push('      <example type="right"><![CDATA[className="bg-primary text-primary-foreground"]]></example>');
  lines.push('    </rule>');
  if (utilities.hasCn) {
    lines.push('    <rule name="use-cn-utility">');
    lines.push(`      <description>Import from ${escapeXml(utilities.cnPath || '')}. Use for conditional classes.</description>`);
    lines.push('      <example type="wrong"><![CDATA[className={"btn " + (active ? "active" : "")}]]></example>');
    lines.push('      <example type="right"><![CDATA[className={cn("btn", active && "active")}]]></example>');
    lines.push('    </rule>');
  }
  if (utilities.hasMode) {
    lines.push('    <rule name="use-mode-design-system">');
    lines.push(`      <description>Import from ${escapeXml(utilities.modePath || '')}. Theme-aware styling.</description>`);
    lines.push('      <example type="wrong"><![CDATA[className="rounded-lg"]]></example>');
    lines.push('      <example type="right"><![CDATA[className={cn("...", mode.radius)}]]></example>');
    lines.push('    </rule>');
  }
  lines.push('  </rules>');
  lines.push('');

  // Components
  lines.push(`  <components count="${components.length}">`);
  const grouped = groupComponentsByDirectory(components);
  for (const [dir, comps] of Object.entries(grouped)) {
    const groupName = formatDirectoryName(dir);
    lines.push(`    <group name="${escapeXml(groupName)}" count="${comps.length}">`);
    for (const comp of comps) {
      const propsAttr = comp.props && comp.props.length > 0 ? ` props="${escapeXml(comp.props.slice(0, 5).join(", "))}"` : '';
      lines.push(`      <component name="${escapeXml(comp.name)}" path="${escapeXml(comp.importPath)}"${propsAttr} />`);
    }
    lines.push('    </group>');
  }
  lines.push('  </components>');
  lines.push('');

  // Hooks
  if (hooks.length > 0) {
    lines.push(`  <hooks count="${hooks.length}">`);
    for (const hook of hooks) {
      lines.push(`    <hook name="${escapeXml(hook.name)}" path="${escapeXml(hook.importPath)}"${hook.isClientOnly ? ' client-only="true"' : ''} />`);
    }
    lines.push('  </hooks>');
    lines.push('');
  }

  // Hub files
  if (importGraph && importGraph.hubFiles.length > 0) {
    lines.push('  <hub-files description="Changes to these affect many files">');
    for (const hub of importGraph.hubFiles.slice(0, 8)) {
      lines.push(`    <file path="${escapeXml(hub.file)}" dependents="${hub.importedByCount}" />`);
    }
    lines.push('  </hub-files>');
    lines.push('');
  }

  // API routes
  if (apiRoutes.length > 0) {
    lines.push(`  <api-routes count="${apiRoutes.length}">`);
    for (const route of apiRoutes.slice(0, 20)) {
      const methods = route.methods.join(",");
      lines.push(`    <route path="${escapeXml(route.path)}" methods="${methods}"${route.isProtected ? ' protected="true"' : ''} />`);
    }
    lines.push('  </api-routes>');
    lines.push('');
  }

  // Database
  if (database && database.models.length > 0) {
    lines.push(`  <database provider="${database.provider}" models="${database.models.length}">`);
    for (const model of database.models.slice(0, 15)) {
      const fields = model.fields.slice(0, 6).join(", ");
      lines.push(`    <model name="${escapeXml(model.name)}" fields="${escapeXml(fields)}" />`);
    }
    lines.push('  </database>');
    lines.push('');
  }

  // Design tokens
  if (Object.keys(tokens.colors).length > 0) {
    lines.push('  <design-tokens>');
    lines.push('    <colors>bg-background, bg-card, bg-muted, bg-primary, bg-secondary, bg-destructive</colors>');
    lines.push('    <text>text-foreground, text-muted-foreground, text-primary-foreground</text>');
    lines.push('    <borders>border-border, border-primary</borders>');
    lines.push('    <forbidden>bg-white, bg-black, bg-gray-*, #hexvalues</forbidden>');
    lines.push('  </design-tokens>');
    lines.push('');
  }

  lines.push('</agents-context>');
  return lines.join("\n");
}

function escapeXml(str: string): string {
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;");
}

/**
 * Generate Getting Started section based on detected patterns
 */
function generateGettingStarted(result: ScanResult): string | null {
  const { commands, database, envVars, framework } = result;
  const steps: string[] = [];

  // 1. Install dependencies
  steps.push("npm install");

  // 2. Environment setup (if env vars detected)
  if (envVars.length > 0) {
    steps.push("");
    steps.push("# Set up environment");
    steps.push("cp .env.example .env.local");
    steps.push("# Edit .env.local with your values");
  }

  // 3. Database setup (if database detected)
  if (database) {
    steps.push("");
    steps.push("# Database setup");
    if (database.provider === "prisma") {
      if (commands.db?.["db:push"]) {
        steps.push("npm run db:push");
      } else if (commands.db?.push) {
        steps.push("npm run db:push");
      } else {
        steps.push("npx prisma db push");
      }
      if (commands.db?.seed || commands.db?.["db:seed"]) {
        steps.push("npm run db:seed    # Optional: seed test data");
      }
    } else if (database.provider === "drizzle") {
      if (commands.db?.push) {
        steps.push("npm run db:push");
      } else {
        steps.push("npx drizzle-kit push");
      }
    }
  }

  // 4. Dev server
  steps.push("");
  steps.push("# Start development");
  if (commands.dev) {
    steps.push("npm run dev");
  } else {
    steps.push("npm run dev");
  }

  // Only generate if we have meaningful content
  if (steps.length <= 3) {
    return null;
  }

  const lines: string[] = [];
  lines.push("## Getting Started");
  lines.push("");
  lines.push("```bash");
  lines.push(...steps);
  lines.push("```");
  lines.push("");

  return lines.join("\n");
}
