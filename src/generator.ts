import type { ScanResult, Component } from "./types.js";

export function generateAgentsMd(result: ScanResult): string {
  const { components, tokens, framework } = result;

  const lines: string[] = [];

  // Header
  lines.push("# AGENTS.md");
  lines.push("");
  lines.push("> Auto-generated by [agentsmith](https://github.com/jpoindexter/agentsmith)");
  lines.push("");

  // Project Overview
  lines.push("## Project Overview");
  lines.push("");
  lines.push(`- **Framework:** ${framework.name}${framework.version ? ` ${framework.version}` : ""}${framework.router ? ` (${framework.router})` : ""}`);
  lines.push(`- **Language:** ${framework.language}`);
  if (framework.styling) {
    lines.push(`- **Styling:** ${framework.styling}`);
  }
  lines.push("");

  // Components
  if (components.length > 0) {
    lines.push("## Components");
    lines.push("");
    lines.push(`Found ${components.length} components in this codebase.`);
    lines.push("");

    // Group components by directory
    const grouped = groupComponentsByDirectory(components);

    for (const [dir, comps] of Object.entries(grouped)) {
      lines.push(`### ${formatDirectoryName(dir)}`);
      lines.push("");
      lines.push("| Component | Import Path |");
      lines.push("|-----------|-------------|");

      for (const comp of comps) {
        const exports = comp.exports.length > 1 ? ` (also: ${comp.exports.slice(1).join(", ")})` : "";
        lines.push(`| ${comp.name}${exports} | \`${comp.importPath}\` |`);
      }
      lines.push("");
    }
  }

  // Design Tokens
  if (Object.keys(tokens.colors).length > 0) {
    lines.push("## Design Tokens");
    lines.push("");
    lines.push("Use these tokens instead of hardcoded values:");
    lines.push("");

    // Colors
    if (Object.keys(tokens.colors).length > 0) {
      lines.push("### Colors");
      lines.push("");
      lines.push("```css");
      for (const [name, value] of Object.entries(tokens.colors)) {
        if (value !== "tailwind-extended") {
          lines.push(`--${name}: ${value};`);
        }
      }
      lines.push("```");
      lines.push("");

      // Tailwind classes
      const semanticColors = Object.keys(tokens.colors).filter(c =>
        ["background", "foreground", "primary", "secondary", "muted", "accent", "destructive", "border", "card", "popover", "success", "warning", "info"].some(s => c.includes(s))
      );

      if (semanticColors.length > 0) {
        lines.push("**Available Tailwind classes:**");
        lines.push("");
        lines.push("```");
        lines.push("// Backgrounds");
        lines.push("bg-background, bg-card, bg-muted, bg-primary, bg-secondary, bg-destructive");
        lines.push("");
        lines.push("// Text");
        lines.push("text-foreground, text-muted-foreground, text-primary, text-destructive");
        lines.push("");
        lines.push("// Borders");
        lines.push("border-border, border-primary");
        lines.push("```");
        lines.push("");
      }
    }

    // Radius
    if (Object.keys(tokens.radius).length > 0) {
      lines.push("### Border Radius");
      lines.push("");
      lines.push("```css");
      for (const [name, value] of Object.entries(tokens.radius)) {
        lines.push(`--${name}: ${value};`);
      }
      lines.push("```");
      lines.push("");
    }
  }

  // Rules
  lines.push("## Rules");
  lines.push("");
  lines.push("1. **Use existing components** - Check the component list above before creating new ones");
  lines.push("2. **Use design tokens** - Never hardcode colors, use semantic tokens");
  lines.push("3. **Follow patterns** - Match the existing code style in this codebase");
  lines.push("");

  return lines.join("\n");
}

function groupComponentsByDirectory(components: Component[]): Record<string, Component[]> {
  const grouped: Record<string, Component[]> = {};

  for (const comp of components) {
    // Get directory from path (e.g., "src/components/ui" from "src/components/ui/button.tsx")
    const parts = comp.path.split("/");
    parts.pop(); // Remove filename
    const dir = parts.join("/") || "root";

    if (!grouped[dir]) {
      grouped[dir] = [];
    }
    grouped[dir].push(comp);
  }

  return grouped;
}

function formatDirectoryName(dir: string): string {
  // Convert "src/components/ui" to "UI Components"
  const lastPart = dir.split("/").pop() || dir;

  if (lastPart === "ui") return "UI Components";
  if (lastPart === "charts") return "Charts";
  if (lastPart === "auth") return "Auth Components";
  if (lastPart === "admin") return "Admin Components";
  if (lastPart === "billing") return "Billing Components";

  // Pascal case the directory name
  return lastPart
    .split(/[-_]/)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(" ");
}
