import type { ScanResult, Component, Framework, Tokens, Hook, Utilities, Commands, ExistingContext, ComponentVariant, ApiRoute, EnvVar, DetectedPatterns, DatabaseSchema } from "./types.js";
import { extractRulesFromClaudeMd } from "./scanners/existing-context.js";

export function generateAgentsMd(result: ScanResult): string {
  const { components, tokens, framework, hooks, utilities, commands, existingContext, variants, apiRoutes, envVars, patterns, database } = result;

  const lines: string[] = [];

  // Header
  lines.push("# AGENTS.md");
  lines.push("");
  lines.push("> Auto-generated by [agentsmith](https://github.com/jpoindexter/agentsmith)");
  lines.push("");

  // Project Overview
  lines.push("## Project Overview");
  lines.push("");
  lines.push("| | |");
  lines.push("|---|---|");
  lines.push(`| **Framework** | ${framework.name}${framework.version ? ` ${framework.version}` : ""}${framework.router ? ` (${framework.router})` : ""} |`);
  lines.push(`| **Language** | ${framework.language} |`);
  if (framework.styling) {
    lines.push(`| **Styling** | ${framework.styling} |`);
  }
  if (utilities.hasShadcn) {
    lines.push(`| **UI Library** | shadcn/ui (${utilities.radixPackages.length} Radix packages) |`);
  }
  if (utilities.hasCn) {
    lines.push(`| **Class Utility** | \`cn()\` from \`${utilities.cnPath}\` |`);
  }
  if (utilities.hasMode) {
    lines.push(`| **Design System** | \`mode\` from \`${utilities.modePath}\` |`);
  }
  lines.push(`| **Components** | ${components.length} |`);
  if (hooks.length > 0) {
    lines.push(`| **Custom Hooks** | ${hooks.length} |`);
  }
  if (apiRoutes.length > 0) {
    lines.push(`| **API Routes** | ${apiRoutes.length} |`);
  }
  if (patterns.patterns.length > 0) {
    lines.push(`| **Patterns** | ${patterns.patterns.length} detected |`);
  }
  lines.push("");

  // Critical Rules - Always first and prominent
  lines.push("## Critical Rules");
  lines.push("");
  lines.push("**These rules are NON-NEGOTIABLE:**");
  lines.push("");
  lines.push("1. **USE EXISTING COMPONENTS** â€” Check the list below before creating ANYTHING new");
  lines.push("2. **USE DESIGN TOKENS** â€” Never hardcode colors (`#fff`, `blue-500`), always use semantic tokens");

  if (utilities.hasCn) {
    lines.push(`3. **USE \`cn()\`** â€” Always use \`cn()\` for conditional classes: \`className={cn("base", condition && "conditional")}\``);
  }
  if (utilities.hasMode) {
    lines.push(`4. **USE \`mode\`** â€” Import design system: \`import { mode } from "${utilities.modePath}"\``);
  }
  lines.push("");

  // Extract rules from existing CLAUDE.md if present
  if (existingContext.hasClaudeMd && existingContext.claudeMdContent) {
    const extractedRules = extractRulesFromClaudeMd(existingContext.claudeMdContent);
    if (extractedRules.length > 0) {
      lines.push("### Additional Rules (from CLAUDE.md)");
      lines.push("");
      for (const rule of extractedRules.slice(0, 10)) {
        lines.push(`- ${rule}`);
      }
      lines.push("");
    }
  }

  // Framework-specific rules
  const frameworkRules = getFrameworkRules(framework, tokens, utilities);
  if (frameworkRules.length > 0) {
    lines.push("### Framework-Specific");
    lines.push("");
    for (const rule of frameworkRules) {
      lines.push(`- ${rule}`);
    }
    lines.push("");
  }

  // Components Section
  if (components.length > 0) {
    lines.push("## Components");
    lines.push("");

    const grouped = groupComponentsByDirectory(components);
    const groupCount = Object.keys(grouped).length;

    lines.push(`${components.length} components across ${groupCount} categories.`);
    lines.push("");

    // Sort groups: UI first, then Charts, then alphabetically
    const sortedGroups = Object.entries(grouped).sort((a, b) => {
      const aName = formatDirectoryName(a[0]);
      const bName = formatDirectoryName(b[0]);
      if (aName === "UI Components") return -1;
      if (bName === "UI Components") return 1;
      if (aName === "Charts") return -1;
      if (bName === "Charts") return 1;
      return aName.localeCompare(bName);
    });

    for (const [dir, comps] of sortedGroups) {
      const groupName = formatDirectoryName(dir);
      lines.push(`### ${groupName} (${comps.length})`);
      lines.push("");

      for (const comp of comps) {
        const allExports = comp.exports.map(e => `\`${e}\``).join(", ");
        lines.push(`- ${allExports} â€” \`${comp.importPath}\``);

        // Add props if available
        if (comp.props && comp.props.length > 0) {
          lines.push(`  - Props: ${comp.props.join(", ")}`);
        }

        // Add description if available
        if (comp.description) {
          lines.push(`  - ${comp.description}`);
        }
      }
      lines.push("");
    }
  }

  // Hooks Section
  if (hooks.length > 0) {
    lines.push("## Custom Hooks");
    lines.push("");
    for (const hook of hooks) {
      const clientNote = hook.isClientOnly ? " *(client only)*" : "";
      lines.push(`- \`${hook.name}\` â€” \`${hook.importPath}\`${clientNote}`);
    }
    lines.push("");
  }

  // Utilities Section
  if (utilities.customUtils.length > 0 || utilities.hasCn) {
    lines.push("## Utilities");
    lines.push("");
    if (utilities.hasCn) {
      lines.push(`- \`cn(...classes)\` â€” Class merging utility from \`${utilities.cnPath}\``);
    }
    for (const util of utilities.customUtils.slice(0, 10)) {
      lines.push(`- \`${util}()\` â€” from \`${utilities.cnPath}\``);
    }
    lines.push("");
  }

  // Component Variants Section
  if (variants.length > 0) {
    lines.push("## Component Variants");
    lines.push("");
    lines.push("Components with CVA variants (use these instead of custom styling):");
    lines.push("");

    for (const v of variants.slice(0, 15)) {
      const variantTypes = Object.entries(v.variants)
        .map(([type, options]) => `${type}: ${options.join(", ")}`)
        .join(" | ");

      lines.push(`- **${v.component}** â€” ${variantTypes}`);
      if (v.defaultVariants) {
        const defaults = Object.entries(v.defaultVariants)
          .map(([k, val]) => `${k}="${val}"`)
          .join(", ");
        lines.push(`  - Defaults: ${defaults}`);
      }
    }
    if (variants.length > 15) {
      lines.push(`- ... and ${variants.length - 15} more`);
    }
    lines.push("");
  }

  // API Routes Section
  if (apiRoutes.length > 0) {
    lines.push("## API Routes");
    lines.push("");
    lines.push(`${apiRoutes.length} API endpoints:`);
    lines.push("");

    for (const route of apiRoutes.slice(0, 30)) {
      const methods = route.methods.join(", ");
      const auth = route.isProtected ? " ðŸ”’" : "";
      lines.push(`- \`${methods}\` \`${route.path}\`${auth}`);
    }
    if (apiRoutes.length > 30) {
      lines.push(`- ... and ${apiRoutes.length - 30} more`);
    }
    lines.push("");
  }

  // Database Models Section
  if (database && database.models.length > 0) {
    lines.push("## Database Models");
    lines.push("");
    lines.push(`${database.models.length} ${database.provider} models:`);
    lines.push("");

    for (const model of database.models.slice(0, 20)) {
      const fieldList = model.fields.slice(0, 6).join(", ");
      const moreFields = model.fields.length > 6 ? `, +${model.fields.length - 6} more` : "";
      lines.push(`- **${model.name}** â€” ${fieldList}${moreFields}`);

      if (model.relations.length > 0) {
        lines.push(`  - Relations: ${model.relations.join(", ")}`);
      }
    }
    if (database.models.length > 20) {
      lines.push(`- ... and ${database.models.length - 20} more`);
    }
    lines.push("");
  }

  // Environment Variables Section
  if (envVars.length > 0) {
    lines.push("## Environment Variables");
    lines.push("");

    // Group by category if available
    const required = envVars.filter(e => e.required);
    const optional = envVars.filter(e => !e.required);

    if (required.length > 0) {
      lines.push("### Required");
      lines.push("");
      lines.push("```bash");
      for (const env of required.slice(0, 20)) {
        lines.push(env.name);
      }
      lines.push("```");
      lines.push("");
    }

    if (optional.length > 0) {
      lines.push("### Optional");
      lines.push("");
      lines.push("```bash");
      for (const env of optional.slice(0, 15)) {
        lines.push(env.name);
      }
      if (optional.length > 15) {
        lines.push(`# ... and ${optional.length - 15} more`);
      }
      lines.push("```");
      lines.push("");
    }
  }

  // Detected Patterns Section
  if (patterns.patterns.length > 0) {
    lines.push("## Code Patterns");
    lines.push("");
    lines.push("Detected patterns in this codebase:");
    lines.push("");

    for (const pattern of patterns.patterns) {
      lines.push(`- ${pattern}`);
    }
    lines.push("");

    // Form pattern guidance
    if (patterns.hasReactHookForm && patterns.hasZod) {
      lines.push("### Form Pattern");
      lines.push("");
      lines.push("```typescript");
      lines.push('import { useForm } from "react-hook-form";');
      lines.push('import { zodResolver } from "@hookform/resolvers/zod";');
      lines.push('import { z } from "zod";');
      lines.push("");
      lines.push("const schema = z.object({");
      lines.push('  name: z.string().min(1, "Required"),');
      lines.push('  email: z.string().email(),');
      lines.push("});");
      lines.push("");
      lines.push("const form = useForm({");
      lines.push("  resolver: zodResolver(schema),");
      lines.push("});");
      lines.push("```");
      lines.push("");
    }
  }

  // Design Tokens
  if (Object.keys(tokens.colors).length > 0) {
    lines.push("## Design Tokens");
    lines.push("");

    // Mode object documentation if present
    if (utilities.hasMode) {
      lines.push("### Using the `mode` Object");
      lines.push("");
      lines.push("```typescript");
      lines.push(`import { mode } from "${utilities.modePath}";`);
      lines.push(`import { cn } from "${utilities.cnPath || "@/lib/utils"}";`);
      lines.push("");
      lines.push("// Usage in components:");
      lines.push("className={cn(");
      lines.push('  "base-styles",');
      lines.push("  mode.radius,        // Dynamic border radius");
      lines.push("  mode.color.bg.surface,");
      lines.push("  mode.typography.body.m");
      lines.push(")}");
      lines.push("```");
      lines.push("");
    }

    lines.push("### Color Tokens");
    lines.push("");
    lines.push("**Use semantic classes, never hardcoded colors:**");
    lines.push("");
    lines.push("```");
    lines.push("// Backgrounds");
    lines.push("bg-background, bg-card, bg-muted, bg-primary, bg-secondary, bg-destructive, bg-accent");
    lines.push("");
    lines.push("// Text");
    lines.push("text-foreground, text-muted-foreground, text-primary-foreground, text-destructive");
    lines.push("");
    lines.push("// Borders");
    lines.push("border-border, border-primary, border-destructive");
    lines.push("");
    lines.push("// NEVER USE:");
    lines.push("// bg-white, bg-black, bg-gray-500, text-gray-600, #ffffff, rgb(...)");
    lines.push("```");
    lines.push("");

    // Show actual token values (collapsed for reference)
    if (Object.keys(tokens.colors).length > 0) {
      lines.push("<details>");
      lines.push("<summary>Raw CSS Variables (click to expand)</summary>");
      lines.push("");
      lines.push("```css");
      for (const [name, value] of Object.entries(tokens.colors).slice(0, 30)) {
        lines.push(`--${name}: ${value};`);
      }
      if (Object.keys(tokens.colors).length > 30) {
        lines.push(`/* ... and ${Object.keys(tokens.colors).length - 30} more */`);
      }
      lines.push("```");
      lines.push("");
      lines.push("</details>");
      lines.push("");
    }
  }

  // Commands Section
  if (commands.dev || commands.build || Object.keys(commands.custom).length > 0) {
    lines.push("## Commands");
    lines.push("");
    lines.push("```bash");
    if (commands.dev) lines.push(`npm run dev          # ${commands.dev}`);
    if (commands.build) lines.push(`npm run build        # ${commands.build}`);
    if (commands.test) lines.push(`npm test             # ${commands.test}`);
    if (commands.lint) lines.push(`npm run lint         # ${commands.lint}`);
    if (commands.typecheck) lines.push(`npm run typecheck    # ${commands.typecheck}`);
    lines.push("```");
    lines.push("");

    // Database commands
    if (commands.db && Object.keys(commands.db).length > 0) {
      lines.push("### Database");
      lines.push("");
      lines.push("```bash");
      for (const [name, cmd] of Object.entries(commands.db)) {
        lines.push(`npm run ${name}`);
      }
      lines.push("```");
      lines.push("");
    }

    // Custom/AI commands
    if (Object.keys(commands.custom).length > 0) {
      lines.push("### Other Commands");
      lines.push("");
      lines.push("```bash");
      for (const [name] of Object.entries(commands.custom).slice(0, 10)) {
        lines.push(`npm run ${name}`);
      }
      lines.push("```");
      lines.push("");
    }
  }

  // Reference to existing docs
  if (existingContext.hasClaudeMd || existingContext.hasAiFolder) {
    lines.push("## Additional Documentation");
    lines.push("");
    if (existingContext.hasClaudeMd) {
      lines.push(`- **${existingContext.claudeMdPath}** â€” Detailed project documentation`);
    }
    if (existingContext.hasAiFolder) {
      lines.push(`- **.ai/ folder** â€” AI-native context files:`);
      for (const file of existingContext.aiFiles.slice(0, 10)) {
        lines.push(`  - \`${file}\``);
      }
      if (existingContext.aiFiles.length > 10) {
        lines.push(`  - ... and ${existingContext.aiFiles.length - 10} more`);
      }
    }
    lines.push("");
  }

  return lines.join("\n");
}

function getFrameworkRules(framework: Framework, tokens: Tokens, utilities: Utilities): string[] {
  const rules: string[] = [];

  // Next.js rules
  if (framework.name === "Next.js") {
    if (framework.router === "App Router") {
      rules.push("Use `'use client'` directive only when component needs interactivity");
      rules.push("Prefer Server Components by default");
      rules.push("Use `next/image` for images, `next/link` for navigation");
    }
  }

  // Tailwind rules
  if (framework.styling === "Tailwind CSS") {
    rules.push("Never use arbitrary values (`w-[137px]`) â€” use scale values");
    if (Object.keys(tokens.radius).length > 0) {
      rules.push("Use design system radius tokens, not arbitrary rounded values");
    }
  }

  // shadcn/ui rules
  if (utilities.hasShadcn) {
    rules.push("Use `asChild` prop when wrapping components with custom elements");
    rules.push("Use CVA variants for consistent component styling");
  }

  // TypeScript rules
  if (framework.language === "TypeScript") {
    rules.push("Type all props and function parameters");
    rules.push("Avoid `any` â€” use proper types or `unknown`");
  }

  return rules;
}

function groupComponentsByDirectory(components: Component[]): Record<string, Component[]> {
  const grouped: Record<string, Component[]> = {};

  for (const comp of components) {
    const parts = comp.path.split("/");
    parts.pop();
    const dir = parts.join("/") || "root";

    if (!grouped[dir]) {
      grouped[dir] = [];
    }
    grouped[dir].push(comp);
  }

  return grouped;
}

function formatDirectoryName(dir: string): string {
  const lastPart = dir.split("/").pop() || dir;

  if (lastPart === "ui") return "UI Components";
  if (lastPart === "charts") return "Charts";
  if (lastPart === "auth") return "Auth Components";
  if (lastPart === "admin") return "Admin Components";
  if (lastPart === "billing") return "Billing Components";

  return lastPart
    .split(/[-_]/)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(" ");
}
