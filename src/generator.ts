import type { ScanResult, Component, Framework, Tokens, Hook, Utilities, Commands, ExistingContext } from "./types.js";
import { extractRulesFromClaudeMd } from "./scanners/existing-context.js";

export function generateAgentsMd(result: ScanResult): string {
  const { components, tokens, framework, hooks, utilities, commands, existingContext } = result;

  const lines: string[] = [];

  // Header
  lines.push("# AGENTS.md");
  lines.push("");
  lines.push("> Auto-generated by [agentsmith](https://github.com/jpoindexter/agentsmith)");
  lines.push("");

  // Project Overview
  lines.push("## Project Overview");
  lines.push("");
  lines.push("| | |");
  lines.push("|---|---|");
  lines.push(`| **Framework** | ${framework.name}${framework.version ? ` ${framework.version}` : ""}${framework.router ? ` (${framework.router})` : ""} |`);
  lines.push(`| **Language** | ${framework.language} |`);
  if (framework.styling) {
    lines.push(`| **Styling** | ${framework.styling} |`);
  }
  if (utilities.hasShadcn) {
    lines.push(`| **UI Library** | shadcn/ui (${utilities.radixPackages.length} Radix packages) |`);
  }
  if (utilities.hasCn) {
    lines.push(`| **Class Utility** | \`cn()\` from \`${utilities.cnPath}\` |`);
  }
  if (utilities.hasMode) {
    lines.push(`| **Design System** | \`mode\` from \`${utilities.modePath}\` |`);
  }
  lines.push(`| **Components** | ${components.length} |`);
  if (hooks.length > 0) {
    lines.push(`| **Custom Hooks** | ${hooks.length} |`);
  }
  lines.push("");

  // Critical Rules - Always first and prominent
  lines.push("## Critical Rules");
  lines.push("");
  lines.push("**These rules are NON-NEGOTIABLE:**");
  lines.push("");
  lines.push("1. **USE EXISTING COMPONENTS** — Check the list below before creating ANYTHING new");
  lines.push("2. **USE DESIGN TOKENS** — Never hardcode colors (`#fff`, `blue-500`), always use semantic tokens");

  if (utilities.hasCn) {
    lines.push(`3. **USE \`cn()\`** — Always use \`cn()\` for conditional classes: \`className={cn("base", condition && "conditional")}\``);
  }
  if (utilities.hasMode) {
    lines.push(`4. **USE \`mode\`** — Import design system: \`import { mode } from "${utilities.modePath}"\``);
  }
  lines.push("");

  // Extract rules from existing CLAUDE.md if present
  if (existingContext.hasClaudeMd && existingContext.claudeMdContent) {
    const extractedRules = extractRulesFromClaudeMd(existingContext.claudeMdContent);
    if (extractedRules.length > 0) {
      lines.push("### Additional Rules (from CLAUDE.md)");
      lines.push("");
      for (const rule of extractedRules.slice(0, 10)) {
        lines.push(`- ${rule}`);
      }
      lines.push("");
    }
  }

  // Framework-specific rules
  const frameworkRules = getFrameworkRules(framework, tokens, utilities);
  if (frameworkRules.length > 0) {
    lines.push("### Framework-Specific");
    lines.push("");
    for (const rule of frameworkRules) {
      lines.push(`- ${rule}`);
    }
    lines.push("");
  }

  // Components Section
  if (components.length > 0) {
    lines.push("## Components");
    lines.push("");

    const grouped = groupComponentsByDirectory(components);
    const groupCount = Object.keys(grouped).length;

    lines.push(`${components.length} components across ${groupCount} categories.`);
    lines.push("");

    // Sort groups: UI first, then Charts, then alphabetically
    const sortedGroups = Object.entries(grouped).sort((a, b) => {
      const aName = formatDirectoryName(a[0]);
      const bName = formatDirectoryName(b[0]);
      if (aName === "UI Components") return -1;
      if (bName === "UI Components") return 1;
      if (aName === "Charts") return -1;
      if (bName === "Charts") return 1;
      return aName.localeCompare(bName);
    });

    for (const [dir, comps] of sortedGroups) {
      const groupName = formatDirectoryName(dir);
      lines.push(`### ${groupName} (${comps.length})`);
      lines.push("");

      for (const comp of comps) {
        const allExports = comp.exports.map(e => `\`${e}\``).join(", ");
        lines.push(`- ${allExports} — \`${comp.importPath}\``);
      }
      lines.push("");
    }
  }

  // Hooks Section
  if (hooks.length > 0) {
    lines.push("## Custom Hooks");
    lines.push("");
    for (const hook of hooks) {
      const clientNote = hook.isClientOnly ? " *(client only)*" : "";
      lines.push(`- \`${hook.name}\` — \`${hook.importPath}\`${clientNote}`);
    }
    lines.push("");
  }

  // Utilities Section
  if (utilities.customUtils.length > 0 || utilities.hasCn) {
    lines.push("## Utilities");
    lines.push("");
    if (utilities.hasCn) {
      lines.push(`- \`cn(...classes)\` — Class merging utility from \`${utilities.cnPath}\``);
    }
    for (const util of utilities.customUtils.slice(0, 10)) {
      lines.push(`- \`${util}()\` — from \`${utilities.cnPath}\``);
    }
    lines.push("");
  }

  // Design Tokens
  if (Object.keys(tokens.colors).length > 0) {
    lines.push("## Design Tokens");
    lines.push("");

    // Mode object documentation if present
    if (utilities.hasMode) {
      lines.push("### Using the `mode` Object");
      lines.push("");
      lines.push("```typescript");
      lines.push(`import { mode } from "${utilities.modePath}";`);
      lines.push(`import { cn } from "${utilities.cnPath || "@/lib/utils"}";`);
      lines.push("");
      lines.push("// Usage in components:");
      lines.push("className={cn(");
      lines.push('  "base-styles",');
      lines.push("  mode.radius,        // Dynamic border radius");
      lines.push("  mode.color.bg.surface,");
      lines.push("  mode.typography.body.m");
      lines.push(")}");
      lines.push("```");
      lines.push("");
    }

    lines.push("### Color Tokens");
    lines.push("");
    lines.push("**Use semantic classes, never hardcoded colors:**");
    lines.push("");
    lines.push("```");
    lines.push("// Backgrounds");
    lines.push("bg-background, bg-card, bg-muted, bg-primary, bg-secondary, bg-destructive, bg-accent");
    lines.push("");
    lines.push("// Text");
    lines.push("text-foreground, text-muted-foreground, text-primary-foreground, text-destructive");
    lines.push("");
    lines.push("// Borders");
    lines.push("border-border, border-primary, border-destructive");
    lines.push("");
    lines.push("// NEVER USE:");
    lines.push("// bg-white, bg-black, bg-gray-500, text-gray-600, #ffffff, rgb(...)");
    lines.push("```");
    lines.push("");

    // Show actual token values (collapsed for reference)
    if (Object.keys(tokens.colors).length > 0) {
      lines.push("<details>");
      lines.push("<summary>Raw CSS Variables (click to expand)</summary>");
      lines.push("");
      lines.push("```css");
      for (const [name, value] of Object.entries(tokens.colors).slice(0, 30)) {
        lines.push(`--${name}: ${value};`);
      }
      if (Object.keys(tokens.colors).length > 30) {
        lines.push(`/* ... and ${Object.keys(tokens.colors).length - 30} more */`);
      }
      lines.push("```");
      lines.push("");
      lines.push("</details>");
      lines.push("");
    }
  }

  // Commands Section
  if (commands.dev || commands.build || Object.keys(commands.custom).length > 0) {
    lines.push("## Commands");
    lines.push("");
    lines.push("```bash");
    if (commands.dev) lines.push(`npm run dev          # ${commands.dev}`);
    if (commands.build) lines.push(`npm run build        # ${commands.build}`);
    if (commands.test) lines.push(`npm test             # ${commands.test}`);
    if (commands.lint) lines.push(`npm run lint         # ${commands.lint}`);
    if (commands.typecheck) lines.push(`npm run typecheck    # ${commands.typecheck}`);
    lines.push("```");
    lines.push("");

    // Database commands
    if (commands.db && Object.keys(commands.db).length > 0) {
      lines.push("### Database");
      lines.push("");
      lines.push("```bash");
      for (const [name, cmd] of Object.entries(commands.db)) {
        lines.push(`npm run ${name}`);
      }
      lines.push("```");
      lines.push("");
    }

    // Custom/AI commands
    if (Object.keys(commands.custom).length > 0) {
      lines.push("### Other Commands");
      lines.push("");
      lines.push("```bash");
      for (const [name] of Object.entries(commands.custom).slice(0, 10)) {
        lines.push(`npm run ${name}`);
      }
      lines.push("```");
      lines.push("");
    }
  }

  // Reference to existing docs
  if (existingContext.hasClaudeMd || existingContext.hasAiFolder) {
    lines.push("## Additional Documentation");
    lines.push("");
    if (existingContext.hasClaudeMd) {
      lines.push(`- **${existingContext.claudeMdPath}** — Detailed project documentation`);
    }
    if (existingContext.hasAiFolder) {
      lines.push(`- **.ai/ folder** — AI-native context files:`);
      for (const file of existingContext.aiFiles.slice(0, 10)) {
        lines.push(`  - \`${file}\``);
      }
      if (existingContext.aiFiles.length > 10) {
        lines.push(`  - ... and ${existingContext.aiFiles.length - 10} more`);
      }
    }
    lines.push("");
  }

  return lines.join("\n");
}

function getFrameworkRules(framework: Framework, tokens: Tokens, utilities: Utilities): string[] {
  const rules: string[] = [];

  // Next.js rules
  if (framework.name === "Next.js") {
    if (framework.router === "App Router") {
      rules.push("Use `'use client'` directive only when component needs interactivity");
      rules.push("Prefer Server Components by default");
      rules.push("Use `next/image` for images, `next/link` for navigation");
    }
  }

  // Tailwind rules
  if (framework.styling === "Tailwind CSS") {
    rules.push("Never use arbitrary values (`w-[137px]`) — use scale values");
    if (Object.keys(tokens.radius).length > 0) {
      rules.push("Use design system radius tokens, not arbitrary rounded values");
    }
  }

  // shadcn/ui rules
  if (utilities.hasShadcn) {
    rules.push("Use `asChild` prop when wrapping components with custom elements");
    rules.push("Use CVA variants for consistent component styling");
  }

  // TypeScript rules
  if (framework.language === "TypeScript") {
    rules.push("Type all props and function parameters");
    rules.push("Avoid `any` — use proper types or `unknown`");
  }

  return rules;
}

function groupComponentsByDirectory(components: Component[]): Record<string, Component[]> {
  const grouped: Record<string, Component[]> = {};

  for (const comp of components) {
    const parts = comp.path.split("/");
    parts.pop();
    const dir = parts.join("/") || "root";

    if (!grouped[dir]) {
      grouped[dir] = [];
    }
    grouped[dir].push(comp);
  }

  return grouped;
}

function formatDirectoryName(dir: string): string {
  const lastPart = dir.split("/").pop() || dir;

  if (lastPart === "ui") return "UI Components";
  if (lastPart === "charts") return "Charts";
  if (lastPart === "auth") return "Auth Components";
  if (lastPart === "admin") return "Admin Components";
  if (lastPart === "billing") return "Billing Components";

  return lastPart
    .split(/[-_]/)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(" ");
}
