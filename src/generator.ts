import type { ScanResult, Component, Framework, Tokens } from "./types.js";

export function generateAgentsMd(result: ScanResult): string {
  const { components, tokens, framework } = result;

  const lines: string[] = [];

  // Header
  lines.push("# AGENTS.md");
  lines.push("");
  lines.push("> Auto-generated by [agentsmith](https://github.com/jpoindexter/agentsmith)");
  lines.push("");

  // Project Overview
  lines.push("## Project Overview");
  lines.push("");
  lines.push(`- **Framework:** ${framework.name}${framework.version ? ` ${framework.version}` : ""}${framework.router ? ` (${framework.router})` : ""}`);
  lines.push(`- **Language:** ${framework.language}`);
  if (framework.styling) {
    lines.push(`- **Styling:** ${framework.styling}`);
  }
  lines.push("");

  // Components
  if (components.length > 0) {
    lines.push("## Components");
    lines.push("");

    // Group components by directory
    const grouped = groupComponentsByDirectory(components);
    const groupCount = Object.keys(grouped).length;

    lines.push(`${components.length} components across ${groupCount} categories.`);
    lines.push("");

    // Sort groups: UI first, then alphabetically
    const sortedGroups = Object.entries(grouped).sort((a, b) => {
      const aName = formatDirectoryName(a[0]);
      const bName = formatDirectoryName(b[0]);
      // UI Components first
      if (aName === "UI Components") return -1;
      if (bName === "UI Components") return 1;
      // Charts second
      if (aName === "Charts") return -1;
      if (bName === "Charts") return 1;
      return aName.localeCompare(bName);
    });

    for (const [dir, comps] of sortedGroups) {
      const groupName = formatDirectoryName(dir);
      lines.push(`### ${groupName} (${comps.length})`);
      lines.push("");

      for (const comp of comps) {
        // Format: `ComponentName` - path
        // If multiple exports: `ComponentName`, `Other`, `Exports` - path
        const allExports = comp.exports.map(e => `\`${e}\``).join(", ");
        lines.push(`- ${allExports} — \`${comp.importPath}\``);
      }
      lines.push("");
    }
  }

  // Design Tokens
  if (Object.keys(tokens.colors).length > 0) {
    lines.push("## Design Tokens");
    lines.push("");
    lines.push("Use these tokens instead of hardcoded values:");
    lines.push("");

    // Colors
    if (Object.keys(tokens.colors).length > 0) {
      lines.push("### Colors");
      lines.push("");
      lines.push("```css");
      for (const [name, value] of Object.entries(tokens.colors)) {
        if (value !== "tailwind-extended") {
          lines.push(`--${name}: ${value};`);
        }
      }
      lines.push("```");
      lines.push("");

      // Tailwind classes
      const semanticColors = Object.keys(tokens.colors).filter(c =>
        ["background", "foreground", "primary", "secondary", "muted", "accent", "destructive", "border", "card", "popover", "success", "warning", "info"].some(s => c.includes(s))
      );

      if (semanticColors.length > 0) {
        lines.push("**Available Tailwind classes:**");
        lines.push("");
        lines.push("```");
        lines.push("// Backgrounds");
        lines.push("bg-background, bg-card, bg-muted, bg-primary, bg-secondary, bg-destructive");
        lines.push("");
        lines.push("// Text");
        lines.push("text-foreground, text-muted-foreground, text-primary, text-destructive");
        lines.push("");
        lines.push("// Borders");
        lines.push("border-border, border-primary");
        lines.push("```");
        lines.push("");
      }
    }

    // Radius
    if (Object.keys(tokens.radius).length > 0) {
      lines.push("### Border Radius");
      lines.push("");
      lines.push("```css");
      for (const [name, value] of Object.entries(tokens.radius)) {
        lines.push(`--${name}: ${value};`);
      }
      lines.push("```");
      lines.push("");
    }
  }

  // Rules
  lines.push("## Rules");
  lines.push("");
  lines.push("### Critical");
  lines.push("");
  lines.push("1. **USE EXISTING COMPONENTS** — Check the list above before creating anything new");
  lines.push("2. **USE DESIGN TOKENS** — Never hardcode colors (`#fff`, `blue-500`), use semantic tokens (`bg-primary`, `text-muted-foreground`)");
  lines.push("");

  // Framework-specific rules
  const frameworkRules = getFrameworkRules(framework, tokens);
  if (frameworkRules.length > 0) {
    lines.push("### Framework-Specific");
    lines.push("");
    for (const rule of frameworkRules) {
      lines.push(`- ${rule}`);
    }
    lines.push("");
  }

  return lines.join("\n");
}

function getFrameworkRules(framework: Framework, tokens: Tokens): string[] {
  const rules: string[] = [];

  // Next.js rules
  if (framework.name === "Next.js") {
    if (framework.router === "App Router") {
      rules.push("Use `'use client'` directive only when component needs interactivity");
      rules.push("Prefer Server Components by default");
      rules.push("Use `next/image` for images, `next/link` for navigation");
    }
  }

  // Tailwind rules
  if (framework.styling === "Tailwind CSS") {
    rules.push("Use `cn()` utility for conditional classes");
    if (Object.keys(tokens.radius).length > 0) {
      rules.push("Use `rounded-dynamic` or design system radius tokens, not arbitrary values");
    }
  }

  // TypeScript rules
  if (framework.language === "TypeScript") {
    rules.push("Type all props and function parameters");
    rules.push("Avoid `any` — use proper types or `unknown`");
  }

  return rules;
}

function groupComponentsByDirectory(components: Component[]): Record<string, Component[]> {
  const grouped: Record<string, Component[]> = {};

  for (const comp of components) {
    // Get directory from path (e.g., "src/components/ui" from "src/components/ui/button.tsx")
    const parts = comp.path.split("/");
    parts.pop(); // Remove filename
    const dir = parts.join("/") || "root";

    if (!grouped[dir]) {
      grouped[dir] = [];
    }
    grouped[dir].push(comp);
  }

  return grouped;
}

function formatDirectoryName(dir: string): string {
  // Convert "src/components/ui" to "UI Components"
  const lastPart = dir.split("/").pop() || dir;

  if (lastPart === "ui") return "UI Components";
  if (lastPart === "charts") return "Charts";
  if (lastPart === "auth") return "Auth Components";
  if (lastPart === "admin") return "Admin Components";
  if (lastPart === "billing") return "Billing Components";

  // Pascal case the directory name
  return lastPart
    .split(/[-_]/)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(" ");
}
