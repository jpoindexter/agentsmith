/**
 * Existing Context Scanner
 *
 * Detects existing AI documentation files in the project:
 * - CLAUDE.md (Claude Code instructions)
 * - AGENTS.md (existing context files)
 * - .ai/ folder (AI context directory)
 * - .cursorrules (Cursor AI rules)
 *
 * @module scanners/existing-context
 */

import { readFileSync, existsSync } from "fs";
import { join } from "path";
import fg from "fast-glob";

/** Existing AI documentation files in the project */
export interface ExistingContext {
  /** Whether CLAUDE.md exists */
  hasClaudeMd: boolean;
  /** Path to CLAUDE.md if found */
  claudeMdPath?: string;
  /** Content of CLAUDE.md */
  claudeMdContent?: string;
  /** Whether a non-agentsmith AGENTS.md exists */
  hasAgentsMd: boolean;
  /** Path to existing AGENTS.md */
  agentsMdPath?: string;
  /** Whether .ai/ folder exists */
  hasAiFolder: boolean;
  /** Files in .ai/ folder */
  aiFiles: string[];
  /** Whether .cursorrules exists */
  hasCursorRules: boolean;
}

/**
 * Scans for existing AI documentation files
 *
 * @param dir - Project root directory
 * @returns Detected existing context files
 */
export async function scanExistingContext(dir: string): Promise<ExistingContext> {
  const context: ExistingContext = {
    hasClaudeMd: false,
    hasAgentsMd: false,
    hasAiFolder: false,
    aiFiles: [],
    hasCursorRules: false,
  };

  // Check for CLAUDE.md
  const claudePaths = ["CLAUDE.md", "claude.md"];
  for (const p of claudePaths) {
    const fullPath = join(dir, p);
    if (existsSync(fullPath)) {
      context.hasClaudeMd = true;
      context.claudeMdPath = p;
      context.claudeMdContent = readFileSync(fullPath, "utf-8");
      break;
    }
  }

  // Check for existing AGENTS.md (don't overwrite if exists and has custom content)
  const agentsPaths = ["AGENTS.md", "agents.md"];
  for (const p of agentsPaths) {
    const fullPath = join(dir, p);
    if (existsSync(fullPath)) {
      const content = readFileSync(fullPath, "utf-8");
      // Only flag as existing if it's NOT auto-generated by us
      if (!content.includes("Auto-generated by [agentsmith]")) {
        context.hasAgentsMd = true;
        context.agentsMdPath = p;
      }
      break;
    }
  }

  // Check for .ai/ folder
  const aiFolderPaths = [".ai", "ai", ".ai-context"];
  for (const folder of aiFolderPaths) {
    const folderPath = join(dir, folder);
    if (existsSync(folderPath)) {
      const files = await fg([`${folder}/**/*.md`], { cwd: dir });
      if (files.length > 0) {
        context.hasAiFolder = true;
        context.aiFiles = files;
        break;
      }
    }
  }

  // Check for .cursorrules
  if (existsSync(join(dir, ".cursorrules"))) {
    context.hasCursorRules = true;
  }

  return context;
}

export function extractRulesFromClaudeMd(content: string): string[] {
  const rules: string[] = [];

  // Look for rules in various formats
  const lines = content.split("\n");
  let inRulesSection = false;

  for (const line of lines) {
    // Detect rules section headers
    if (line.match(/^#+\s*(Rules|Critical|Important|Guidelines)/i)) {
      inRulesSection = true;
      continue;
    }

    // End of section
    if (inRulesSection && line.match(/^#+\s/)) {
      inRulesSection = false;
    }

    // Extract numbered rules or bullet points
    if (inRulesSection) {
      const ruleMatch = line.match(/^[\d\-\*]+\.?\s*\*?\*?(.+)\*?\*?/);
      if (ruleMatch && ruleMatch[1].trim().length > 10) {
        rules.push(ruleMatch[1].trim().replace(/\*\*/g, ""));
      }
    }

    // Also look for inline critical rules
    if (line.includes("NEVER") || line.includes("ALWAYS") || line.includes("MUST")) {
      const cleanLine = line.replace(/^[\s\-\*\d\.]+/, "").trim();
      if (cleanLine.length > 20 && !rules.includes(cleanLine)) {
        rules.push(cleanLine);
      }
    }
  }

  return rules.slice(0, 15); // Limit to 15 most important rules
}
